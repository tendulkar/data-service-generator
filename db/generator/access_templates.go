package generator

import (
	"fmt"
	"strings"

	"stellarsky.ai/platform/codegen/data-service-generator/db/generator/defs"
)

const modelTemplate = `// Code generated by platform; DO NOT EDIT.

package {{.Model.Family}}

import (
	"database/sql"
	"fmt"
	"time"
)

type {{.Model.Name}} struct {
	{{- range .Model.Attributes }}
	{{ .Name }} {{ .Type }}
	{{- end }}
}

type {{.Model.Name}}DB struct {
	dbConn *sql.DB
	preparedCache map[string]*sql.Stmt
	argidMap map[int]string
}

func prepareAndCacheQuery(db *{{.Model.Name}}DB, queryName string, query string) error {
	stmt, err := db.dbConn.Prepare(query)
	if err != nil {
		return nil, err
	}
	db.preparedCache[queryName] = stmt
	return nil
}

func setup{{$.Model.Name}}DB(db *{{.Model.Name}}DB) error {
	{{- range .Access.Find }}
	{{ .Name }}Query := ` + "`SELECT {{ .Attributes | Join }} FROM {{ $.Model.Name }} WHERE {{ .Filter | WhereClause }}`" + `
	prepareAndCacheQuery(db, "{{.Name}}", {{ .Name }}Query)
	{{- end}}

	{{- range .Access.Update }}
	{{ .Name }}Query := ` + "`UPDATE {{ $.Model.Name }} SET {{ .Set | SetClause }} WHERE {{ .Filter | WhereClause }}`" + `
	prepareAndCacheQuery(db, "{{.Name}}", {{ .Name }}Query)
	{{- end}}

	{{- range .Access.Add }}
	{{ .Name }}Query := ` + "`INSERT INTO {{ $.Model.Name }} ({{ .Values | AttributeNames }}) VALUES ({{ .Values | AttributeValues }}) RETURNING id`" + `
	prepareAndCacheQuery(db, "{{.Name}}", {{ .Name }}Query)
	{{- end}}

	{{- range .Access.AddOrReplace }}
	{{ .Name }}Query := ` + "`INSERT INTO {{ $.Model.Name }} ({{ .Values | AttributeNames }}) VALUES ({{ .Values | AttributeValues }}) ON CONFLICT DO UPDATE SET {{ .Values | SetClause }} RETURNING id, (xmax = 0)`" + `
	prepareAndCacheQuery(db, "{{.Name}}", {{ .Name }}Query)
	{{- end}}

	{{- range .Access.Delete }}
	{{ .Name }}Query := ` + "`DELETE FROM {{ $.Model.Name }} WHERE {{ .Filter | WhereClause }}`" + `
	prepareAndCacheQuery(db, "{{.Name}}", {{ .Name }}Query)
	{{- end}}
}

// Generated access functions
{{- range .Access.Find }}
func {{ .Name }}(db *{{.Model.Name}}DB, accessRequest *AccessConfig) ([]{{$.Model.Name}}, error) {
	stmt := db.preparedCache["{{ .Name }}"]
	rows, err := stmt.Query(QueryArgs(accessRequest, "READ"))
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []{{$.Model.Name}}
	for rows.Next() {
		var item {{$.Model.Name}}
		err := rows.Scan({{ .Attributes | ScanArgs }})
		if err != nil {
			return nil, err
		}
		results = append(results, item)
	}
	return results, nil
}
{{- end }}

{{- range .Access.Update }}
func {{ .Name }}(db *{{.Model.Name}}DB, request *AccessConfig) (int64, error) {

	stmt := db.preparedCache["{{ .Name }}"]	
	result, err := stmt.Exec({{ .Filter | QueryArgs}})
	if err != nil {
		return 0, err
	}
	rowsAffected, err := result.RowsAffected()
	return rowsAffected, err
}
{{- end }}

{{- range .Access.Add }}
func {{ .Name }}(db *{{.Model.Name}}DB, request *AccessConfig) (int64, error) {
	stmt := db.preparedCache["{{ .Name }}"]

	var id int64
	err = stmt.QueryRow().Scan(&id)
	return id, err
}
{{- end }}

{{- range .Access.AddOrReplace }}
func {{ .Name }}(db *{{.Model.Name}}DB, request *AccessConfig) (int64, bool, error) {
	stmt := db.preparedCache["{{ .Name }}"]
	var id int64
	var inserted bool
	err = stmt.QueryRow().Scan(&id, &inserted)
	return id, inserted, err
}
{{- end }}

{{- range .Access.Delete }}
func {{ .Name }}(db *{{.Model.Name}}DB, request *AccessConfig) error {
	stmt := db.preparedCache["{{ .Name }}"]
	_, err = stmt.Exec()
	return err
}
{{- end }}
`

func Args(filters []defs.Filter) string {
	var args []string
	for _, cond := range filters {
		if len(cond.Conditions) > 0 {
			args = append(args, Args(cond.Conditions))
		} else {
			args = append(args, fmt.Sprintf("%s %s", cond.Attribute, "string"))
		}
	}
	return strings.Join(args, ", ")
}

func Join(args []string) string {
	return strings.Join(args, ", ")
}

func WhereClause(filters []defs.Filter) string {
	result, _ := PrepareFilters(filters)
	return result
}

func PrepareWhereClause(filters []defs.Filter) string {
	result, _ := PrepareFilters(filters)
	return result
}

func AttributeNames(updates []defs.Update) string {
	var attributes []string
	for _, update := range updates {
		attributes = append(attributes, update.Attribute)
	}
	return strings.Join(attributes, ", ")
}

func AttributeValues(updates []defs.Update) string {
	var values []string
	for i := range updates {
		values = append(values, fmt.Sprintf("$%d", i+1))
	}
	return strings.Join(values, ", ")
}

func SetClause(updates []defs.Update) string {
	var clauses []string
	for i, update := range updates {
		clauses = append(clauses, fmt.Sprintf("%s = $%d", update.Attribute, i+1))
	}
	return strings.Join(clauses, ", ")
}

func AutoincrementClause(attributes []string) string {
	var clauses []string
	for _, attribute := range attributes {
		clauses = append(clauses, fmt.Sprintf("%s = %s + 1", attribute, attribute))
	}
	return strings.Join(clauses, ", ")
}

func CaptureTimestampClause(attributes []string) string {
	var clauses []string
	for _, attribute := range attributes {
		clauses = append(clauses, fmt.Sprintf("%s = now()", attribute))
	}
	return strings.Join(clauses, ", ")
}

func ScanArgs(attributes []string) string {
	var args []string
	for _, attribute := range attributes {
		args = append(args, fmt.Sprintf("&item.%s", attribute))
	}
	return strings.Join(args, ", ")
}

func ApplyTransformation(attribute string, transformation string) string {
	if transformation == "" {
		return attribute
	}
	return fmt.Sprintf("%s(%s)", transformation, attribute)
}

func QueryArgs(request defs.Request) string {
	var args []string
	for _, param := range request.Parameters {
		args = append(args, param.Attribute)
	}
	return strings.Join(args, ", ")
}

const findTemplate = `stmt := db.preparedCache["{{ .Name }}"]
	rows, err := stmt.Query(QueryArgs(accessRequest, "READ"))
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []{{.ModelName}}
	for rows.Next() {
		var item {{.ModelName}}
		err := rows.Scan({{ .ScanAttributes }})
		if err != nil {
			return nil, err
		}
		results = append(results, item)
	}
	return results, nil
`
